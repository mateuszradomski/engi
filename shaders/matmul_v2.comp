#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_compute_shader : enable

#define MATRIX_SIZE 4096
#define WORKGROUP_SIZE 8
#define TS WORKGROUP_SIZE
layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE) in;

layout(set = 0, binding = 0) readonly buffer bufA
{
   float matrixA[];
};

layout(set = 0, binding = 1) readonly buffer bufB
{
   float matrixB[];
};

layout(set = 0, binding = 2) writeonly buffer bufC
{
   float matrixC[];
};

shared float ATile[TS][TS];
shared float BTile[TS][TS];

void main()
{
   const uint globalRow = gl_GlobalInvocationID.x;
   const uint globalCol = gl_GlobalInvocationID.y;
   const uint localRow = gl_LocalInvocationID.x;
   const uint localCol = gl_LocalInvocationID.y;

   float sum = 0.0;

   const int numTiles = MATRIX_SIZE / TS;
   for(uint tileIndex = 0; tileIndex < numTiles; tileIndex++)
   {
      // Each worker in the thread group will load the value it's responsible for
      const uint tiledRow = TS * tileIndex + localRow;
      const uint tiledCol = TS * tileIndex + localCol;
      ATile[localRow][localCol] = matrixA[tiledCol + MATRIX_SIZE * globalRow];
      BTile[localRow][localCol] = matrixB[globalCol + MATRIX_SIZE * tiledRow];

      // Wait for all workers to finish sync
      memoryBarrierShared();
      barrier();

      for(int k = 0; k < TS; k++)
      {
         sum += ATile[localRow][k] * BTile[k][localCol];
      }

      // Wait for all workers to finish before writing the result back in
      memoryBarrierShared();
      barrier();
   }

   matrixC[MATRIX_SIZE * globalRow + globalCol] = sum;
}